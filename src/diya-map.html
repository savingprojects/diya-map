<link rel="import" href="bower_components/polymer/polymer.html">
<script src="bower_components/d3/d3.min.js"></script>


<polymer-element name="diya-map" attributes="diya fitmap">
	<template>
		<style type="text/css">
			:host{
				display: block;
				position: relative;
			}

			svg{
				width: 100%;
				height: 100%;
				overflow: hidden;
			}

			#places{
				fill: black;
			}
		</style>
		


		<svg id="map" version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
			<g id="mapContent" x="10" y="10">
				<image id="mapImage" width="100%" height="100%" x="0" y="0" xlink:href="cmap2.png" />

				<g id="places">
					
				</g>
			<g>
		</svg>

	</template>

	<script type="text/javascript">
	Polymer({
		ready: function(){
			var that = this;

			this.PLACE_ACTIVATION_THRESOLD = 0.2;

			this.initMapNavigation();
			this.initDragPlaceBehavior();

			this.places = [];
			this.updatePlaces();

			this.currentPlaceId = 0;

			this.fitmap = false;
		},

		addPlace: function(x, y, value, activated){
			var that = this;

			var remotePlace = this.getRemotePlace(this.places.length);
			if(remotePlace){
				console.log(remotePlace);
				x = remotePlace.x;
				y = remotePlace.y;
			}
			this.places.push({x: x, y: y, value: value, activated: activated});
		},

		setCurrentPlace: function(id){
			if(id >= this.places.length) return ;

			this.currentPlaceId = id;

			for(var i = 0; i<this.places.length; i++){
				this.places[i].activated = false;
			}
			this.places[id].activated = true;
		},

		updatePlace: function(id, value){

			if(id < this.places.length){
				this.places[id].value = value;
				return false;
			}
			else if(id === this.places.length && value > this.PLACE_ACTIVATION_THRESOLD){
				var vx;
				var vy;

				if(this.places.length >= 2){
					vx = 2*this.places[id-1].x - this.places[id-2].x;
					vy = 2*this.places[id-1].y - this.places[id-2].y;
				}else if(this.places.length > 0){
					vx = this.places[id - 1].x + 10;
					vy = this.places[id - 1].y + 10;
				}else{
					vx = 100;
					vy = 100;
				}

				this.addPlace(vx,vy, value, true);

				return true;
			}else{
				return false; //Should not happen
			}
		},

		updatePlaces: function(){
			var that = this;

			var placeElements = d3.select(this.$.places)
			  .selectAll('.place')
			  .data(this.places);

			placeElements.enter()
			  .append('svg:circle')
			  .call(this.dragPlaceBehavior);

			placeElements.exit().remove();

			placeElements.attr('class', 'place')
			  .attr('cx', function(d) { return d.x; })
			  .attr('cy', function(d) { return d.y; })
			  .attr('r', function(d) { return d.value * 5; })
			  .attr('fill', function(d) { return d.activated ? 'green' : 'black'});
		},

		initDragPlaceBehavior: function(){
			var that = this;

			//Drag n Drop for Places
			this.dragPlaceBehavior = d3.behavior.drag()
				.on('dragstart', function(){

					d3.event.sourceEvent.stopPropagation();

					d3.select(this)
					  .transition()
					  .attr('fill', 'blue')
				})
				.on('drag', function(){
					d3.select(this)
					  .attr('cx', function(d){ return d.x = d3.event.x; })
					  .attr('cy', function(d){ return d.y = d3.event.y; })
				})
				.on('dragend', function(){
					d3.select(this)
					  .transition()
					  .attr('fill', 'black');

				});
		},

		//Init map translation and zoom
		initMapNavigation: function(){
			var that = this;

			this.$.mapImage.tx = 0;
			this.$.mapImage.ty = 0;

			this.$.mapImage.scale = 1;

			function updateMapContent(){

				var x = d3.event.translate[0];
				var y = d3.event.translate[1];
				var scale = d3.event.scale;

				d3.select(that.$.mapContent)
					.attr('transform', 'translate('+x+','+y+'), scale('+scale+')');
			}

			function updateMapImage(){
				var x = d3.event.translate[0];
				var y = d3.event.translate[1];
				var scale = d3.event.scale;

				d3.select(that.$.mapImage)
					.attr('transform', 'translate('+x+','+y+'), scale('+scale+')');

				that.$.mapImage.tx = x;
				that.$.mapImage.ty = y;
				that.$.mapImage.scale = scale;
			}

			//zoom in/out for the whole map
			this.zoomMapBehavior = d3.behavior.zoom()
				.scaleExtent([0.1,20])
				.on('zoom', function(){
					if(that.fitmap){
						updateMapImage();
					}else{
						updateMapContent();
					}
				})

			d3.select(this.$.map)
				.call(this.zoomMapBehavior);
		},

		fitMap: function(fit){
			this.fitmap = fit;
			if(!fit){
				console.log("send"+this.$.mapImage.scale);
				this.diya.get({
					service: 'maps',
					func: 'UpdateMap',
					obj: [ 'default' ],
					data: {
						scale: this.$.mapImage.scale,
						tx: this.$.mapImage.tx,
						ty: this.$.mapImage.ty
					}
				})
			}
		},

		diyaChanged: function(){
			if(this.diya){
				this.diyaConnected(this.diya);
			}else{
				this.diyaDisconnected();
			}
		},

		diyaConnected: function(diya){
			this.connectPromethe();
			this.getDefaultMap();
		},

		diyaDisconnected: function(){
			
		},

		getDefaultMap: function(){
			var that = this;

			this.diya.listen({
				service: 'maps',
				func: 'ListenMap',
				obj: ['default']
			},function(data){
				if(data == null) return ;
				that.currentMapId = data.id;

				console.log(data.tx+":"+data.ty+":"+data.scale);

				//set saved fit map
				d3.select(that.$.mapImage)
					.attr('transform', 'translate('+data.tx+','+data.ty+'), scale('+data.scale+')');


				//Set saved places
				for(var i = 0; i<data.places.length; i++){
					var place = that.places[data.places[i].neuronId];
					if(!place) continue ;

					place.x = data.places[i].x;
					place.y = data.places[i].y;
					place.label = data.places[i].label;
				}

				that.remotePlaces = data.places;

				that.updatePlaces();
			});
		},

		getRemotePlace: function(id){
			
			if(this.remotePlaces === undefined) return null;

			for(var i = 0; i<this.remotePlaces.length; i++){
				if(this.remotePlaces[i].neuronId === id) return this.remotePlaces[i];
			}
			return null;
		},

		savePlaces: function(id){
			
			for(var i=0; i<this.places.length; i++){
				this.diya.get({
					service: 'maps',
					func: 'UpdatePlace',
					data: {
						mapId: this.currentMapId,
						neuronId: i,
						x: this.places[i].x,
						y: this.places[i].y
					}
				},function(data){
					//Succeed / fail ?
				});
			}
		},

		connectPromethe: function(){
			var that = this;

			this.promethe = new diya.Promethe(this.diya);

			this.promethe.onclose = function(){
				that.prometheDisconnected();
			};
			
			this.promethe.use(/^map\.places$/, function(neuron){
				if(neuron.type === 'input')
					that.setPlaceNeuron(neuron);
				else
					console.log("error map.places should be an input");
			});

			this.promethe.connect();
		},

		prometheDisconnected: function(){
			var that = this;

			this.promethe = null;

			while(this.places.length){
				this.places.pop();
			}
			this.updatePlaces();

			setTimeout(function(){
				console.log("try reconnecting promethe");
				that.connectPromethe();
			},3000);
		},

		setPlaceNeuron: function(neuron){
			var that = this;

			neuron.setOnMessage(function(msg){
				var placeNeurons = new DataView(msg.data);
				var maxId = 0;
				var newPlace = false;

				for(var i=0; i<neuron.size; i++){
					var value = placeNeurons.getFloat32(i*4, true);
					newPlace = that.updatePlace(i, value);
					if(value > placeNeurons.getFloat32(maxId*4, true)) maxId = i;
				}

				that.setCurrentPlace(maxId);

				that.updatePlaces();


			});
		}
	});
	</script>

</polymer-element>
